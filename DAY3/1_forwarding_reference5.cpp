// 이 예제가 "핵심" 입니다. 

// T&& : 모든 타입(임의타입)의 lvalue 와 rvalue 를 모두 받을수 있다.

template<typename T> void f4(T&& a)
{
}

int main()
{
	int n = 3;

	// #1. 타입인자를 명시적으로 전달하는 경우
	f4<int>(3);		// T = int		T&& = int&&			f4(int&& a) 인 함수 생성
	f4<int&>(n);	// T = int&		T&& = int& &&		f4(int&  a) 인 함수 생성
	f4<int&&>(3);	// T = int&&	T&& = int&& &&		f4(int&& a) 인 함수 생성


	// #2. 타입을 명시적으로 전달하지 않는 경우
	// => 컴파일러가 함수 인자를 보고, 함수를 생성하기 위해 최대한 노력해서 T를 결정!
	
	f4(n);	// n 은 int 타입. 
			// 1. T=int 로 결정하면, f4(int&& a) 함수 생성하고, n 은 lvalue 이므로 에러
			// 2. T=int&로 결정하면, f4(int& a)  함수 생성하고, f4(n) 에러 아님. 
			// => 답은 2
			// => 왜 n 은 int 인데, T=int& 로 추론되나요 ???
			// => T=int  로 추론해서 함수를 만들면 n 을 받을수 없지만
			//    T=int& 로 추론해서 함수를 만들면 n 을 받을수 있습니다.

	f4(3);	// T=int, 그런데, 인자는 T&& 이므로 생성된 함수는 f4(int&&) 함수 생성
	
}

